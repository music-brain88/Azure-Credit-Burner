// azure-credit-burner - 3Êó•Èñì„Åß7‰∏á„Éâ„É´ÂàÜ„ÅÆAzure„ÇØ„É¨„Ç∏„ÉÉ„Éà„Çí‰Ωø„ÅÑÂàá„Çã„ÉÑ„Éº„É´
// RustÁâàÂÆüË£Ö

use chrono::prelude::*;
use reqwest::{self, header};
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::{path::Path, sync::Arc, time::Duration};
use tokio::{fs, process::Command, time};

use anyhow::{Result, anyhow, bail};
use base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};
use clap::Parser;
use dotenv::dotenv;
use futures::{StreamExt, stream};
use ignore::{Walk, WalkBuilder};
use log::{error, info};
use simple_logger::SimpleLogger;
use walkdir::WalkDir;

// llm„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆ„Çπ„Ç≠„Éº„Éû„ÇíÂà©Áî®
mod llm;
use llm::categories::{self, get_category_japanese};
use llm::schemas::{
    github_response::{FileInfo, RepoInfo},
    openai_response::{ChatMessage, Endpoint, OpenAIResponse, ResponseData},
};

// „Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥ÂºïÊï∞„ÅÆÂÆöÁæ©
#[derive(Parser, Debug)]
#[clap(
    name = "azure-credit-burner",
    about = "GPT-4„ÅßAzure„ÇØ„É¨„Ç∏„ÉÉ„Éà„ÇíÂäπÁéáÁöÑ„Å´Ê∂àË≤ª„Åô„Çã„ÉÑ„Éº„É´",
    version = "1.0.0"
)]
struct Args {
    /// GitHub„ÅÆ„Ç¢„ÇØ„Çª„Çπ„Éà„Éº„ÇØ„É≥
    #[clap(long, env = "GITHUB_TOKEN")]
    github_token: String,

    /// ‰øùÂ≠òÂÖà„Éá„Ç£„É¨„ÇØ„Éà„É™
    #[clap(long, default_value = "llm_debates")]
    output_dir: String,

    /// ÂêåÊôÇÂÆüË°åÊï∞
    #[clap(long, default_value = "8")]
    concurrency: usize,

    /// „Éï„Ç°„Ç§„É´„ÅÇ„Åü„Çä„ÅÆÊúÄÂ§ßÂá¶ÁêÜÊï∞
    #[clap(long, default_value = "50")]
    max_files: usize,

    /// ÊúÄÂ§ß„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫Ôºà„Éê„Ç§„ÉàÔºâ
    #[clap(long, default_value = "100000")]
    max_file_size: usize,
}

// Ê∑±Êéò„ÇäË≥™Âïè„Ç´„ÉÜ„Ç¥„É™
struct DeepQuestions;

impl DeepQuestions {
    fn new() -> Self {
        DeepQuestions {}
    }

    fn get_question(&self, category: &str, index: usize) -> String {
        // Êó•Êú¨Ë™û„Ç´„ÉÜ„Ç¥„É™Âêç„Åã„ÇâËã±Ë™û„Ç´„ÉÜ„Ç¥„É™Âêç„Å´Â§âÊèõ
        let category_en = match category {
            "„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£" => "architecture",
            "„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ" => "performance",
            "„Çª„Ç≠„É•„É™„ÉÜ„Ç£" => "security",
            "„ÉÜ„Çπ„ÉàÂìÅË≥™" => "testing",
            "„Éâ„É°„Ç§„É≥ÂàÜÊûê" => "domain",
            "ÂàÜÊï£„Ç∑„Çπ„ÉÜ„É†" => "distributed",
            "„Ç≥„Éº„Éâ‰øùÂÆàÊÄß" => "maintainability",
            _ => "architecture", // „Éá„Éï„Ç©„É´„Éà„ÅØ„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£
        };

        // „Ç´„ÉÜ„Ç¥„É™„Éï„Ç°„Ç§„É´„Åã„ÇâË≥™Âïè„ÇíÂèñÂæó
        match categories::get_question(category_en, index) {
            Ok(question) => question,
            Err(_) => {
                // „Ç®„É©„ÉºÊôÇ„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØË≥™Âïè
                "„Åì„ÅÆ„É™„Éù„Ç∏„Éà„É™„Å´„Å§„ÅÑ„Å¶„ÄÅ„Åï„Çâ„Å´Ë©≥Á¥∞„Å™ÂàÜÊûê„ÇíË°å„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Ç≥„Éº„Éâ„ÅÆÂìÅË≥™„ÇÑË®≠Ë®à„Å´„Å§„ÅÑ„Å¶Áâπ„Å´ÈáçË¶Å„Å™ÁÇπ„ÅØ‰Ωï„Åß„Åó„Çá„ÅÜ„ÅãÔºü".to_string()
            }
        }
    }

    fn get_category(&self, turn: usize) -> String {
        let categories = vec![
            "„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£",
            "„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ",
            "„Çª„Ç≠„É•„É™„ÉÜ„Ç£",
            "„ÉÜ„Çπ„ÉàÂìÅË≥™",
            "„Éâ„É°„Ç§„É≥ÂàÜÊûê",
            "ÂàÜÊï£„Ç∑„Çπ„ÉÜ„É†",
            "„Ç≥„Éº„Éâ‰øùÂÆàÊÄß",
        ];
        categories[turn % categories.len()].to_string()
    }
}

// ÂàÜÊûê„Çø„Ç§„Éó„ÅÆÂÆöÁæ©
fn get_debate_types() -> Vec<String> {
    vec![
        "„Ç≥„Éº„Éâ„É¨„Éì„É•„Éº„ÉªÂàÜÊûê".to_string(),
        "„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£„ÅÆÂº∑„Åø„ÉªÂº±„ÅøË©ï‰æ°".to_string(),
        "ÂÆüË£Ö„ÅÆ‰ª£Êõø„Ç¢„Éó„É≠„Éº„ÉÅÊèêÊ°à".to_string(),
        "„Çª„Ç≠„É•„É™„ÉÜ„Ç£ËÑÜÂº±ÊÄß„ÅÆÊ§úÂá∫".to_string(),
        "„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©Âåñ„ÅÆÊèêÊ°à".to_string(),
        "API„Éá„Ç∂„Ç§„É≥„ÅÆÊâπË©ï".to_string(),
        "„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆ„É≠„Éº„Éâ„Éû„ÉÉ„Éó‰∫àÊ∏¨".to_string(),
        "„É©„Ç§„Çª„É≥„Çπ„Å®„Ç™„Éº„Éó„É≥„ÇΩ„Éº„Çπ„Ç≥„Éü„É•„Éã„ÉÜ„Ç£„Å∏„ÅÆÂΩ±ÈüøÂàÜÊûê".to_string(),
    ]
}

// GitHub„ÇØ„É©„Ç§„Ç¢„É≥„Éà
struct GitHubClient {
    token: String,
    output_dir: String,
    max_file_size: usize,
}

impl GitHubClient {
    fn new(token: String, output_dir: String, max_file_size: usize) -> Self {
        GitHubClient {
            token,
            output_dir,
            max_file_size,
        }
    }

    // „É™„Éù„Ç∏„Éà„É™„Çí„ÇØ„É≠„Éº„É≥„Åô„Çã
    async fn clone_repository(&self, repo_info: &RepoInfo) -> Result<String> {
        let repo_dir = format!(
            "{}/repos/{}_{}",
            self.output_dir, repo_info.owner, repo_info.repo
        );

        // „Åô„Åß„Å´„ÇØ„É≠„Éº„É≥Ê∏à„Åø„Åã„ÉÅ„Çß„ÉÉ„ÇØ
        if Path::new(&repo_dir).exists() {
            info!(
                "üîÑ „É™„Éù„Ç∏„Éà„É™„ÅØ„Åô„Åß„Å´„ÇØ„É≠„Éº„É≥Ê∏à„Åø: {}/{}",
                repo_info.owner, repo_info.repo
            );
        } else {
            // „Éá„Ç£„É¨„ÇØ„Éà„É™‰ΩúÊàê
            fs::create_dir_all(Path::new(&repo_dir).parent().unwrap()).await?;

            // git clone „Ç≥„Éû„É≥„ÉâÂÆüË°å
            let clone_url = format!(
                "https://{}@github.com/{}/{}.git",
                self.token, repo_info.owner, repo_info.repo
            );

            info!(
                "üîΩ „É™„Éù„Ç∏„Éà„É™„Çí„ÇØ„É≠„Éº„É≥‰∏≠: {}/{}",
                repo_info.owner, repo_info.repo
            );

            let output = Command::new("git")
                .args(["clone", "--depth", "1", &clone_url, &repo_dir])
                .output()
                .await?;

            if !output.status.success() {
                let error = String::from_utf8_lossy(&output.stderr);
                return Err(anyhow!("„É™„Éù„Ç∏„Éà„É™„ÅÆ„ÇØ„É≠„Éº„É≥„Å´Â§±Êïó: {}", error));
            }

            info!(
                "‚úÖ „É™„Éù„Ç∏„Éà„É™„ÅÆ„ÇØ„É≠„Éº„É≥ÊàêÂäü: {}/{}",
                repo_info.owner, repo_info.repo
            );
        }

        Ok(repo_dir)
    }

    // „Ç≥„Éº„Éâ„Éï„Ç°„Ç§„É´„ÇíÂà§ÂÆö„Åô„ÇãÈñ¢Êï∞
    fn is_code_file(path: &str) -> bool {
        let code_extensions = [
            ".py", ".js", ".ts", ".java", ".c", ".cpp", ".h", ".hpp", ".go", ".rs", ".rb", ".php",
            ".md", ".cs", ".jsx", ".tsx", ".css", ".scss", ".less", ".html", ".xml", ".json",
            ".yaml", ".yml", ".toml", ".sh", ".bash", ".ps1", ".sql", ".graphql", ".proto", ".kt",
            ".swift",
        ];

        code_extensions.iter().any(|&ext| path.ends_with(ext))
    }

    // Èô§Â§ñ„Åô„Åπ„Åç„Éá„Ç£„É¨„ÇØ„Éà„É™„ÇíÂà§ÂÆö„Åô„ÇãÈñ¢Êï∞
    fn is_excluded_dir(path: &str) -> bool {
        let excluded_dirs = [
            "/.git/",
            "/node_modules/",
            "/target/",
            "/build/",
            "/dist/",
            "/bin/",
            "/obj/",
            "/.idea/",
            "/.vscode/",
            "/vendor/",
            "/deps/",
            "/_build/",
            "/venv/",
            "/__pycache__/",
        ];

        excluded_dirs.iter().any(|&dir| path.contains(dir))
    }

    // „É™„Éù„Ç∏„Éà„É™„Éï„Ç°„Ç§„É´„ÇíÂèñÂæó
    async fn fetch_repo_files(&self, repo_info: &RepoInfo) -> Result<Vec<FileInfo>> {
        info!(
            "‚¨áÔ∏è „É™„Éù„Ç∏„Éà„É™„Åã„Çâ„Éï„Ç°„Ç§„É´ÂèñÂæó‰∏≠: {}/{}",
            repo_info.owner, repo_info.repo
        );

        // „É™„Éù„Ç∏„Éà„É™„Çí„ÇØ„É≠„Éº„É≥
        let repo_dir = self.clone_repository(repo_info).await?;

        // „Éï„Ç°„Ç§„É´‰∏ÄË¶ß„ÇíÂèñÂæó
        let mut files = Vec::new();

        // ignore„ÇØ„É¨„Éº„Éà„Çí‰Ωø„Å£„Å¶gitignore„Å™„Å©„ÇíËÄÉÊÖÆ„Åó„Åü„Éï„Ç°„Ç§„É´Ëµ∞Êüª
        let walker = WalkBuilder::new(&repo_dir)
            .standard_filters(true) // .gitignore„ÇíËÄÉÊÖÆ
            .hidden(false) // Èö†„Åó„Éï„Ç°„Ç§„É´„ÇÇÂØæË±°„Å´
            .build();

        let mut all_files = Vec::new();

        // „Éï„Ç°„Ç§„É´„Çí„Åô„Åπ„Å¶ÂèéÈõÜ
        for result in walker {
            match result {
                Ok(entry) => {
                    let path = entry.path();
                    if path.is_file() {
                        let path_str = path.to_string_lossy().to_string();

                        // „Ç≥„Éº„Éâ„Éï„Ç°„Ç§„É´„Åã„Å§Èô§Â§ñÂØæË±°„Åß„Å™„ÅÑ„Éï„Ç°„Ç§„É´„ÅÆ„Åø
                        if Self::is_code_file(&path_str) && !Self::is_excluded_dir(&path_str) {
                            all_files.push(path.to_path_buf());
                        }
                    }
                }
                Err(e) => {
                    error!("‚ö†Ô∏è „Éï„Ç°„Ç§„É´ÂàóÊåô„Ç®„É©„Éº: {}", e);
                }
            }
        }

        // ÂÑ™ÂÖàÂ∫¶„ÅÆÈ´ò„ÅÑ„Éï„Ç°„Ç§„É´„ÇíÂÖàÈ†≠„Å´
        all_files.sort_by(|a, b| {
            let a_str = a.to_string_lossy();
            let b_str = b.to_string_lossy();
            let a_priority = is_priority_file(&a_str);
            let b_priority = is_priority_file(&b_str);

            if a_priority && !b_priority {
                std::cmp::Ordering::Less
            } else if !a_priority && b_priority {
                std::cmp::Ordering::Greater
            } else {
                a.cmp(b)
            }
        });

        // „Éï„Ç°„Ç§„É´Êï∞„ÇíÂà∂Èôê
        let max_files = repo_info.max_files.min(all_files.len());
        let selected_files = all_files.into_iter().take(max_files);

        // „Éï„Ç°„Ç§„É´ÂÜÖÂÆπ„ÇíË™≠„ÅøËæº„ÇÄ
        for path in selected_files {
            // Áõ∏ÂØæ„Éë„Çπ„ÇíÂèñÂæó
            let rel_path = path
                .strip_prefix(&repo_dir)
                .map_err(|e| anyhow!("„Éë„ÇπÂ§âÊèõ„Ç®„É©„Éº: {}", e))?
                .to_string_lossy()
                .to_string();

            // „Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„Çí„ÉÅ„Çß„ÉÉ„ÇØ
            match fs::metadata(&path).await {
                Ok(metadata) => {
                    // Â§ß„Åç„Åô„Åé„Çã„Éï„Ç°„Ç§„É´„ÅØ„Çπ„Ç≠„ÉÉ„Éó
                    if metadata.len() > self.max_file_size as u64 {
                        info!(
                            "‚è© „Çµ„Ç§„Ç∫„ÅåÂ§ß„Åç„ÅÑ„Åü„ÇÅ„Çπ„Ç≠„ÉÉ„Éó: {} ({} bytes)",
                            rel_path,
                            metadata.len()
                        );
                        continue;
                    }
                }
                Err(e) => {
                    error!("‚ö†Ô∏è „Éï„Ç°„Ç§„É´„É°„Çø„Éá„Éº„ÇøÂèñÂæó„Ç®„É©„Éº: {} - {}", rel_path, e);
                    continue;
                }
            }

            // „Éï„Ç°„Ç§„É´ÂÜÖÂÆπ„ÇíË™≠„ÅøËæº„ÇÄ
            match fs::read_to_string(&path).await {
                Ok(content) => {
                    info!("‚úÖ „Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„ÅøÊàêÂäü: {}", rel_path);

                    // Èï∑„Åô„Åé„Çã„Éï„Ç°„Ç§„É´„ÅØÂÖàÈ†≠ÈÉ®ÂàÜ„ÅÆ„Åø
                    let content = if content.len() > self.max_file_size {
                        // ÊñáÂ≠óÂçò‰Ωç„ÅßÂá¶ÁêÜ„Åó„Å¶ÂÆâÂÖ®„Å´Âàá„ÇäÂèñ„Çã
                        let truncated: String = content.chars().take(self.max_file_size).collect();
                        format!("{}...\n(ÂÜÖÂÆπÁúÅÁï•)...", truncated)
                    } else {
                        content
                    };

                    files.push(FileInfo {
                        path: rel_path,
                        content,
                    });
                }
                Err(e) => {
                    error!("‚ö†Ô∏è „Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº: {} - {}", rel_path, e);
                }
            }
        }

        info!("üóÇÔ∏è ÂèñÂæó„Éï„Ç°„Ç§„É´Êï∞: {}/{}", files.len(), max_files);

        if files.is_empty() {
            bail!("„É™„Éù„Ç∏„Éà„É™„Åã„Çâ„Éï„Ç°„Ç§„É´„ÇíÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü");
        }

        Ok(files)
    }
}

// ÂÑ™ÂÖàÂ∫¶„ÅÆÈ´ò„ÅÑ„Éï„Ç°„Ç§„É´„Åã„Å©„ÅÜ„Åã„ÇíÂà§ÂÆö
fn is_priority_file(path: &str) -> bool {
    path.ends_with("README.md")
        || path.contains("main.")
        || path.contains("core.")
        || path.contains("/src/")
            && (path.contains("mod.rs") || path.contains("lib.rs") || path.contains("index."))
}

// Azure OpenAI „ÇØ„É©„Ç§„Ç¢„É≥„Éà
struct AzureOpenAIClient {
    client: reqwest::Client,
    endpoint: Endpoint,
    api_version: String,
}

impl AzureOpenAIClient {
    fn new(endpoint: Endpoint) -> Self {
        let client = reqwest::Client::new();

        AzureOpenAIClient {
            client,
            endpoint,
            api_version: "2024-12-01-preview".to_string(),
        }
    }

    async fn chat_completion(
        &self,
        messages: &[ChatMessage],
        model: &str,
        max_tokens: usize, //o1„Çí‰Ωø„ÅÜÂ†¥Âêà„ÅØmax_completion_tokens„Å´Â§âÊõ¥„Åó„Å¶„Å≠
        _temperature: f32, //o1„Çí‰Ωø„ÅÜÂ†¥Âêà„ÅØtemperature„Åå‰∏çË¶Å
    ) -> Result<(String, usize)> {
        let url = format!(
            "{}/openai/deployments/{}/chat/completions?api-version={}",
            self.endpoint.endpoint, model, self.api_version
        );

        let request_body = json!({
            "messages": messages,
            "max_completion_tokens": max_tokens,
            //"temperature": temperature, //o1„Çí‰Ωø„ÅÜÂ†¥Âêà„ÅØtemperature„Åå‰∏çË¶Å
        });

        let response = self
            .client
            .post(&url)
            .header("api-key", &self.endpoint.key)
            .json(&request_body)
            .send()
            .await?;

        if response.status().is_success() {
            let openai_response: OpenAIResponse = response.json().await?;
            Ok((
                openai_response.choices[0].message.content.clone(),
                openai_response.usage.total_tokens,
            ))
        } else {
            let status = response.status();
            let error_text = response.text().await?;
            Err(anyhow!(
                "OpenAI API „Ç®„É©„Éº: „Çπ„ÉÜ„Éº„Çø„Çπ {}, „É¨„Çπ„Éù„É≥„Çπ: {}",
                status,
                error_text
            ))
        }
    }
}

// „É™„Éù„Ç∏„Éà„É™ÂàÜÊûêÁî®„Éó„É≠„É≥„Éó„ÉàÁîüÊàê
fn generate_repo_debate_prompt(
    repo_info: &RepoInfo,
    repo_files: &[FileInfo],
    debate_type: &str,
) -> (String, String) {
    // README„ÇíÊé¢„Åô
    let readme_content = repo_files
        .iter()
        .find(|file| file.path.contains("README.md"))
        .map(|file| &file.content[..])
        .unwrap_or("README.md„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ");

    // „Éï„Ç°„Ç§„É´‰∏ÄË¶ß„ÅÆ„Çµ„Éû„É™„Éº
    let file_summary = repo_files
        .iter()
        .map(|file| format!("- {}", file.path))
        .collect::<Vec<_>>()
        .join("\n");

    // „Çµ„É≥„Éó„É´„Éï„Ç°„Ç§„É´
    let mut file_samples = String::new();
    for (i, file) in repo_files.iter().enumerate() {
        if i >= 5 {
            break;
        }

        file_samples.push_str(&format!("\n--- {} ---\n", file.path));

        // Èï∑„Åô„Åé„ÇãÂ†¥Âêà„ÅØ‰∏ÄÈÉ®„ÇíË°®Á§∫ÔºàÊñáÂ≠óÂçò‰Ωç„ÅßÂÆâÂÖ®„Å´Âàá„ÇäÂèñ„ÇäÔºâ
        let content = if file.content.len() > 2000 {
            // ÊñáÂ≠óÂçò‰Ωç„ÅßÂá¶ÁêÜ„Åó„Å¶ÂÆâÂÖ®„Å´Âàá„ÇäÂèñ„Çã
            let truncated: String = file.content.chars().take(2000).collect();
            format!("{}...\n(ÁúÅÁï•)...", truncated)
        } else {
            file.content.clone()
        };

        file_samples.push_str(&content);
    }

    // „ÉÜ„É≥„Éó„É¨„Éº„ÉàË™≠„ÅøËæº„Åø„ÇíË©¶„Åø„Çã
    let system_prompt = match llm::prompts::load_template("repo_analysis") {
        Ok(template) => {
            // „ÉÜ„É≥„Éó„É¨„Éº„ÉàÂÜÖ„ÅÆÂ§âÊï∞„ÇíÁΩÆÊèõ
            let variables = vec![
                ("owner".to_string(), repo_info.owner.clone()),
                ("repo".to_string(), repo_info.repo.clone()),
                ("debate_type".to_string(), debate_type.to_string()),
                ("file_count".to_string(), repo_files.len().to_string()),
                ("file_summary".to_string(), file_summary),
                (
                    "readme".to_string(),
                    readme_content.chars().take(1000).collect::<String>(),
                ),
                ("file_samples".to_string(), file_samples),
            ];

            llm::prompts::render_template(&template, &variables)
        }
        Err(_) => {
            // „ÉÜ„É≥„Éó„É¨„Éº„ÉàË™≠„ÅøËæº„Åø„Ç®„É©„ÉºÊôÇ„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Éó„É≠„É≥„Éó„Éà
            format!(
                r#"„ÅÇ„Å™„Åü„ÅØÈ´òÂ∫¶„Å™AI„Ç®„É≥„Ç∏„Éã„Ç¢„Å®„Åó„Å¶„ÄÅGitHub„É™„Éù„Ç∏„Éà„É™„Äå{}/{}„Äç„ÅÆÂàÜÊûê„ÇíË°å„ÅÑ„Åæ„Åô„ÄÇ
„Åì„ÅÆ„É™„Éù„Ç∏„Éà„É™„Å´„Å§„ÅÑ„Å¶„Äå{}„Äç„Å®„ÅÑ„ÅÜË¶≥ÁÇπ„Åã„ÇâË©≥Á¥∞„Å´Ë≠∞Ë´ñ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

„Äê„É™„Éù„Ç∏„Éà„É™ÊÉÖÂ†±„Äë
ÊâÄÊúâËÄÖ: {}
„É™„Éù„Ç∏„Éà„É™Âêç: {}
„Éï„Ç°„Ç§„É´Êï∞: {}

„Äê„Éï„Ç°„Ç§„É´‰∏ÄË¶ß„Äë
{}

„ÄêREADMEÊ¶ÇË¶Å„Äë
{}

„Äê‰∏ªË¶Å„Éï„Ç°„Ç§„É´„Çµ„É≥„Éó„É´„Äë
{}

„ÅÇ„Å™„Åü„ÅÆ‰ªªÂãô:

1. „Åì„ÅÆ„É™„Éù„Ç∏„Éà„É™„ÅÆ„Ç≥„Éº„Éâ„ÇíË©≥Á¥∞„Å´ÂàÜÊûê„Åó„ÄÅ„Äå{}„Äç„ÅÆË¶≥ÁÇπ„Åã„ÇâÊ∑±„ÅèËÄÉÂØü„Åó„Å¶„Åè„Å†„Åï„ÅÑ
2. ÊäÄË°ìÁöÑ„Å™Èï∑ÊâÄ„ÉªÁü≠ÊâÄ„ÇíÁâπÂÆö„Åó„ÄÅÂÖ∑‰ΩìÁöÑ„Å™„Ç≥„Éº„Éâ‰æã„ÇíÂºïÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ
3. „ÅÇ„Å™„Åü„ÅÆÂ∞ÇÈñÄÁü•Ë≠ò„Å´Âü∫„Å•„ÅÑ„ÅüÊîπÂñÑÊ°à„ÇÑ‰ª£Êõø„Ç¢„Éó„É≠„Éº„ÉÅ„ÇíÊèêÊ°à„Åó„Å¶„Åè„Å†„Åï„ÅÑ
4. Ê•≠Áïå„ÅÆ„Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ„Å®ÊØîËºÉ„Åó„ÅüË©ï‰æ°„ÇíË°å„Å£„Å¶„Åè„Å†„Åï„ÅÑ
5. „Åì„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÂ∞ÜÊù•ÊÄß„ÇÑÁô∫Â±ïÊñπÂêë„Å´„Å§„ÅÑ„Å¶‰∫àÊ∏¨„Åó„Å¶„Åè„Å†„Åï„ÅÑ

„Åß„Åç„Çã„Å†„ÅëÂÖ∑‰ΩìÁöÑ„Å™„Ç≥„Éº„Éâ‰æã„ÇÑÊäÄË°ìÁöÑË©≥Á¥∞„Å´Âü∫„Å•„ÅÑ„Å¶„ÄÅÊ∑±„ÅÑÊ¥ûÂØü„ÇíÊèê‰æõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"#,
                repo_info.owner,
                repo_info.repo,
                debate_type,
                repo_info.owner,
                repo_info.repo,
                repo_files.len(),
                file_summary,
                &readme_content.chars().take(1000).collect::<String>(),
                file_samples,
                debate_type
            )
        }
    };

    // ÂàùÊúü„É°„ÉÉ„Çª„Éº„Ç∏
    let initial_message = format!(
        "„Äå{}/{}„Äç„É™„Éù„Ç∏„Éà„É™„Çí„Äå{}„Äç„ÅÆË¶≥ÁÇπ„Åã„ÇâÂàÜÊûê„Åó„Åæ„Åô„ÄÇ„Åæ„Åö„ÄÅ„Åì„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ¶ÇË¶Å„Å®‰∏ªË¶Å„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÇíÁâπÂÆö„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ",
        repo_info.owner, repo_info.repo, debate_type
    );

    (system_prompt, initial_message)
}

// Ê¨°„ÅÆË≥™Âïè„ÇíÂèñÂæó
fn get_next_question(repo_info: &RepoInfo, deep_questions: &DeepQuestions, turn: usize) -> String {
    if turn == 1 {
        return format!(
            "„Äå{}/{}„Äç„É™„Éù„Ç∏„Éà„É™„ÇíÂàÜÊûê„Åó„Åæ„Åô„ÄÇ„Åæ„Åö„ÄÅ„Åì„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ¶ÇË¶Å„Å®‰∏ªË¶Å„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÇíÁâπÂÆö„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ",
            repo_info.owner, repo_info.repo
        );
    }

    let category = deep_questions.get_category(turn - 2);
    let question_index = (turn - 2) / 7; // 7„Ç´„ÉÜ„Ç¥„É™

    deep_questions.get_question(&category, question_index)
}

// ‰øùÂ≠òÂá¶ÁêÜ
async fn save_response(
    base_dir: &str,
    repo_info: &RepoInfo,
    debate_type: &str,
    endpoint_name: &str,
    turn: usize,
    messages: &[ChatMessage],
    tokens_used: usize,
) -> Result<String> {
    let repo_dir = format!("{}/{}_{}", base_dir, repo_info.owner, repo_info.repo);

    // „Éá„Ç£„É¨„ÇØ„Éà„É™„Åå„Å™„Åë„Çå„Å∞‰ΩúÊàê
    fs::create_dir_all(&repo_dir).await?;

    // „Éï„Ç°„Ç§„É´Âêç„ÇíÁîüÊàê
    let now = Utc::now();
    let filename = format!(
        "{}/{}_{}_{}_turn{}.json",
        repo_dir,
        debate_type.replace(" ", "_"),
        endpoint_name,
        turn,
        now.format("%Y%m%d_%H%M%S")
    );

    // ‰øùÂ≠ò„Éá„Éº„Çø„Çí‰ΩúÊàê
    let response_data = ResponseData {
        repo: format!("{}/{}", repo_info.owner, repo_info.repo),
        debate_type: debate_type.to_string(),
        turn,
        timestamp: now.to_rfc3339(),
        endpoint: endpoint_name.to_string(),
        messages: messages.to_vec(),
        tokens_used,
    };

    // JSON„Å´„Åó„Å¶‰øùÂ≠ò
    let json_data = serde_json::to_string_pretty(&response_data)?;
    fs::write(&filename, json_data).await?;

    Ok(filename)
}

// „É™„Éù„Ç∏„Éà„É™ÂàÜÊûê„ÅÆÂÆüË°å
async fn debate_runner(
    github_client: Arc<GitHubClient>,
    endpoints: Arc<Vec<Endpoint>>,
    repo_info: RepoInfo,
    debate_type: String,
    endpoint_index: usize,
    base_dir: String,
) -> Result<()> {
    let endpoint = &endpoints[endpoint_index % endpoints.len()];
    let openai_client = AzureOpenAIClient::new(endpoint.clone());

    info!(
        "[{}] „É™„Éù„Ç∏„Éà„É™ÂàÜÊûêÈñãÂßã: {}/{} ({})",
        endpoint.name, repo_info.owner, repo_info.repo, debate_type
    );

    // „É™„Éù„Ç∏„Éà„É™„Éï„Ç°„Ç§„É´„ÇíÂèñÂæó
    let repo_files = match github_client.fetch_repo_files(&repo_info).await {
        Ok(files) => files,
        Err(e) => {
            error!(
                "[{}] „É™„Éù„Ç∏„Éà„É™„Éï„Ç°„Ç§„É´ÂèñÂæó„Ç®„É©„Éº: {}/{} - {}",
                endpoint.name, repo_info.owner, repo_info.repo, e
            );
            return Err(e);
        }
    };

    // ÂàùÊúü„Éó„É≠„É≥„Éó„ÉàÁîüÊàê
    let (system_prompt, initial_message) =
        generate_repo_debate_prompt(&repo_info, &repo_files, &debate_type);

    // ‰ºöË©±Â±•Ê≠¥„Çí‰øùÊåÅ
    let mut messages = vec![
        ChatMessage {
            role: "system".to_string(),
            content: system_prompt,
        },
        ChatMessage {
            role: "user".to_string(),
            content: initial_message,
        },
    ];

    // Ë≥™ÂïèÁîüÊàêÁî®
    let deep_questions = DeepQuestions::new();

    // ‰ºöË©±„É´„Éº„Éó
    let mut turn = 1;
    while turn <= 20 {
        // ÊúÄÂ§ß20„Çø„Éº„É≥„Åæ„Åß„Å´Âà∂Èôê
        info!(
            "[{}] ÂàÜÊûêÂÆüË°å‰∏≠: {}/{} ({}) - „Çø„Éº„É≥ {}",
            endpoint.name, repo_info.owner, repo_info.repo, debate_type, turn
        );

        // OpenAI API„ÇíÂëº„Å≥Âá∫„Åó
        match openai_client
            .chat_completion(
                &messages, "o1", // ÊúÄÂ§ß„É¢„Éá„É´„Çí‰ΩøÁî®
                4000, // Èï∑„ÅÑÂá∫Âäõ
                0.8,  // ÈÅ©Â∫¶„Å™ÂâµÈÄ†ÊÄß
            )
            .await
        {
            Ok((response, tokens_used)) => {
                // „É¨„Çπ„Éù„É≥„Çπ„Çí‰ºöË©±Â±•Ê≠¥„Å´ËøΩÂä†
                messages.push(ChatMessage {
                    role: "assistant".to_string(),
                    content: response,
                });

                // ÁµêÊûú„Çí‰øùÂ≠ò
                match save_response(
                    &base_dir,
                    &repo_info,
                    &debate_type,
                    &endpoint.name,
                    turn,
                    &messages,
                    tokens_used,
                )
                .await
                {
                    Ok(filename) => {
                        info!(
                            "[{}] ‰øùÂ≠òÂÆå‰∫Ü: {} („Éà„Éº„ÇØ„É≥Êï∞: {})",
                            endpoint.name, filename, tokens_used
                        );
                    }
                    Err(e) => {
                        error!(
                            "[{}] ‰øùÂ≠ò„Ç®„É©„Éº: {}/{} - „Çø„Éº„É≥ {} - {}",
                            endpoint.name, repo_info.owner, repo_info.repo, turn, e
                        );
                    }
                }

                // Ê¨°„ÅÆË≥™Âïè„ÇíÁîüÊàê
                let next_question = get_next_question(&repo_info, &deep_questions, turn);

                messages.push(ChatMessage {
                    role: "user".to_string(),
                    content: next_question,
                });

                turn += 1;

                // „ÇØ„É¨„Ç∏„ÉÉ„ÉàÊ∂àË≤ª„ÅÆ„Åü„ÇÅ„ÅÇ„Åæ„ÇäÂæÖÊ©ü„Åó„Å™„ÅÑ
                time::sleep(Duration::from_millis(500)).await;
            }
            Err(e) => {
                error!(
                    "[{}] OpenAI API „Ç®„É©„Éº: {}/{} - „Çø„Éº„É≥ {} - {}",
                    endpoint.name, repo_info.owner, repo_info.repo, turn, e
                );

                // „Ç®„É©„ÉºÊôÇ„ÅØÂ∞ë„ÅóÂæÖ„Å£„Å¶„É™„Éà„É©„Ç§
                time::sleep(Duration::from_secs(5)).await;

                // 3ÂõûÈÄ£Á∂ö„Åß„Ç®„É©„Éº„Å´„Å™„Å£„Åü„ÇâÁµÇ‰∫Ü
                if turn > 3 {
                    bail!("OpenAI API Âëº„Å≥Âá∫„Åó„Å´Ë§áÊï∞ÂõûÂ§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÁµÇ‰∫Ü„Åó„Åæ„Åô„ÄÇ");
                }
            }
        }
    }

    Ok(())
}

// „É°„Ç§„É≥Èñ¢Êï∞
#[tokio::main]
async fn main() -> Result<()> {
    // .env„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„Åø
    dotenv().ok();

    // „É≠„Ç¨„ÉºÂàùÊúüÂåñ
    SimpleLogger::new()
        .with_level(log::LevelFilter::Info)
        .init()
        .unwrap();

    // „Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥ÂºïÊï∞„ÇíËß£Êûê
    let args = Args::parse();

    // „Éô„Éº„Çπ„Éá„Ç£„É¨„ÇØ„Éà„É™‰ΩúÊàê
    // .envË®≠ÂÆö„Åæ„Åü„ÅØÂºïÊï∞„ÅÆÂÄ§„Çí‰ΩøÁî®
    let output_dir = std::env::var("OUTPUT_DIR").unwrap_or_else(|_| args.output_dir.clone());
    fs::create_dir_all(&output_dir).await?;

    // Azure OpenAI„Ç®„É≥„Éâ„Éù„Ç§„É≥„ÉàË®≠ÂÆö„Çí.env„Åã„ÇâÂèñÂæó
    let endpoints = vec![
        Endpoint {
            name: "east-us".to_string(),
            key: std::env::var("AZURE_OPENAI_KEY_EAST_US")
                .unwrap_or_else(|_| "YOUR_KEY_1".to_string()),
            endpoint: std::env::var("AZURE_OPENAI_ENDPOINT_EAST_US")
                .unwrap_or_else(|_| "https://eastus.api.cognitive.microsoft.com".to_string()),
        },
        Endpoint {
            name: "west-us".to_string(),
            key: std::env::var("AZURE_OPENAI_KEY_WEST_US")
                .unwrap_or_else(|_| "YOUR_KEY_2".to_string()),
            endpoint: std::env::var("AZURE_OPENAI_ENDPOINT_WEST_US")
                .unwrap_or_else(|_| "https://westus.api.cognitive.microsoft.com".to_string()),
        },
        Endpoint {
            name: "japan-east".to_string(),
            key: std::env::var("AZURE_OPENAI_KEY_JAPAN_EAST")
                .unwrap_or_else(|_| "YOUR_KEY_3".to_string()),
            endpoint: std::env::var("AZURE_OPENAI_ENDPOINT_JAPAN_EAST")
                .unwrap_or_else(|_| "https://japaneast.api.cognitive.microsoft.com".to_string()),
        },
        Endpoint {
            name: "europe-west".to_string(),
            key: std::env::var("AZURE_OPENAI_KEY_EUROPE_WEST")
                .unwrap_or_else(|_| "YOUR_KEY_4".to_string()),
            endpoint: std::env::var("AZURE_OPENAI_ENDPOINT_EUROPE_WEST")
                .unwrap_or_else(|_| "https://westeurope.api.cognitive.microsoft.com".to_string()),
        },
    ];

    // GitHub„É™„Éù„Ç∏„Éà„É™Ë®≠ÂÆö„Çí.env„Åã„ÇâË™≠„ÅøËæº„Åø
    let mut github_repos = Vec::new();

    // „É™„Éù„Ç∏„Éà„É™1
    if let (Ok(owner), Ok(repo)) = (std::env::var("REPO_OWNER_1"), std::env::var("REPO_NAME_1")) {
        let max_files = std::env::var("REPO_MAX_FILES_1")
            .unwrap_or_else(|_| "50".to_string())
            .parse::<usize>()
            .unwrap_or(50);

        github_repos.push(RepoInfo {
            owner,
            repo,
            max_files,
        });
    }

    // „É™„Éù„Ç∏„Éà„É™2
    if let (Ok(owner), Ok(repo)) = (std::env::var("REPO_OWNER_2"), std::env::var("REPO_NAME_2")) {
        let max_files = std::env::var("REPO_MAX_FILES_2")
            .unwrap_or_else(|_| "50".to_string())
            .parse::<usize>()
            .unwrap_or(50);

        github_repos.push(RepoInfo {
            owner,
            repo,
            max_files,
        });
    }

    // „É™„Éù„Ç∏„Éà„É™3
    if let (Ok(owner), Ok(repo)) = (std::env::var("REPO_OWNER_3"), std::env::var("REPO_NAME_3")) {
        let max_files = std::env::var("REPO_MAX_FILES_3")
            .unwrap_or_else(|_| "50".to_string())
            .parse::<usize>()
            .unwrap_or(50);

        github_repos.push(RepoInfo {
            owner,
            repo,
            max_files,
        });
    }

    // .env„Åã„ÇâË™≠„ÅøËæº„ÇÅ„Å™„Åã„Å£„ÅüÂ†¥Âêà„ÅÆ„Éá„Éï„Ç©„É´„ÉàË®≠ÂÆö
    if github_repos.is_empty() {
        github_repos = vec![
            RepoInfo {
                owner: "your-org".to_string(),
                repo: "your-private-repo1".to_string(),
                max_files: 50,
            },
            RepoInfo {
                owner: "your-org".to_string(),
                repo: "your-private-repo2".to_string(),
                max_files: 50,
            },
            RepoInfo {
                owner: "your-org".to_string(),
                repo: "your-private-repo3".to_string(),
                max_files: 50,
            },
        ];
    }

    // Ë≠∞Ë´ñ„Çø„Ç§„Éó
    let debate_types = get_debate_types();

    // GitHub„ÇØ„É©„Ç§„Ç¢„É≥„Éà (.env„Åæ„Åü„ÅØ„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥ÂºïÊï∞„Åã„Çâ)
    let github_token = std::env::var("GITHUB_TOKEN").unwrap_or_else(|_| args.github_token.clone());
    let github_client = Arc::new(GitHubClient::new(
        github_token,
        output_dir.clone(),
        args.max_file_size,
    ));

    // Azure„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
    let endpoints = Arc::new(endpoints);

    // ÂêåÊôÇÂÆüË°åÊï∞„Çí.env„Åã„ÇâÂèñÂæóÔºà„Éá„Éï„Ç©„É´„Éà„ÅØ„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥ÂºïÊï∞Ôºâ
    let concurrency = std::env::var("CONCURRENCY")
        .ok()
        .and_then(|s| s.parse::<usize>().ok())
        .unwrap_or(args.concurrency);

    // ÈñãÂßã„É°„ÉÉ„Çª„Éº„Ç∏
    info!("üí∞üíª Azure Credit Burner Ëµ∑Âãï‰∏≠... üí∞üíª");
    info!("ÂêåÊôÇÂÆüË°åÊï∞: {}", concurrency);
    info!("ÂØæË±°„É™„Éù„Ç∏„Éà„É™Êï∞: {}", github_repos.len());
    info!("„Éï„Ç°„Ç§„É´Êï∞‰∏äÈôê: {}", args.max_files);
    info!("„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫‰∏äÈôê: {} „Éê„Ç§„Éà", args.max_file_size);

    // „Çø„Çπ„ÇØ‰ΩúÊàê
    let mut tasks = Vec::new();
    let mut task_index = 0;

    // ÂêÑ„É™„Éù„Ç∏„Éà„É™„Å®Ë≠∞Ë´ñ„Çø„Ç§„Éó„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ„Åß„Çø„Çπ„ÇØ„Çí‰ΩúÊàê
    // Vec<(RepoInfo, String, usize)>„ÅÆ„Çø„Éó„É´„Å´„Åó„Å¶Âæå„ÅßÂá¶ÁêÜ
    let mut task_configs = Vec::new();

    for (i, repo_info) in github_repos.iter().enumerate() {
        for (j, debate_type) in debate_types.iter().enumerate() {
            // Âêå„Åò„É™„Éù„Ç∏„Éà„É™„Åß„ÇÇÁï∞„Å™„ÇãË¶ñÁÇπ„ÅßÂàÜÊûê
            let endpoint_index = task_index % endpoints.len();

            // „Çø„Çπ„ÇØË®≠ÂÆö„ÇíË®òÈå≤
            task_configs.push((repo_info.clone(), debate_type.clone(), endpoint_index));
            task_index += 1;

            // ËøΩÂä†„Åß„Çø„Çπ„ÇØ„Çí‰ΩúÊàê„Åó„Å¶„ÇØ„É¨„Ç∏„ÉÉ„ÉàÊ∂àË≤ª„ÇíÂ¢ó„ÇÑ„Åô
            if i % 2 == 0 && j % 2 == 0 {
                let extra_endpoint_index = (task_index + 2) % endpoints.len();

                // ËøΩÂä†„Çø„Çπ„ÇØ„ÇÇË®òÈå≤
                task_configs.push((repo_info.clone(), debate_type.clone(), extra_endpoint_index));
                task_index += 1;
            }
        }
    }

    // Ë®òÈå≤„Åó„Åü„Çø„Çπ„ÇØË®≠ÂÆö„ÇíÂÖÉ„Å´„Çø„Çπ„ÇØ„Çí‰ΩúÊàê
    for (repo_info, debate_type, endpoint_index) in task_configs {
        let github_client_owned = github_client.clone();
        let endpoints_owned = endpoints.clone();
        let output_dir_owned = output_dir.clone();

        tasks.push(tokio::spawn(async move {
            debate_runner(
                github_client_owned,
                endpoints_owned,
                repo_info,
                debate_type,
                endpoint_index,
                output_dir_owned,
            )
            .await
        }));
    }

    // „Éê„ÉÉ„Éï„Ç°„É™„É≥„Ç∞„Åó„Å¶ÂêåÊôÇÂÆüË°åÊï∞„ÇíÂà∂Èôê
    let mut active_tasks = Vec::new();

    for task in tasks {
        active_tasks.push(task);

        if active_tasks.len() >= concurrency {
            let (completed, _index, remaining) = futures::future::select_all(active_tasks).await;

            // ÁµêÊûú„ÇíÂá¶ÁêÜ
            match completed {
                Ok(Ok(_)) => {
                    info!("üéâ „Çø„Çπ„ÇØÂÆå‰∫Ü");
                }
                Ok(Err(e)) => {
                    error!("‚ùå „Çø„Çπ„ÇØ„Ç®„É©„Éº: {}", e);
                }
                Err(e) => {
                    error!("üí• „Çø„Çπ„ÇØÂÆüË°å„Ç®„É©„Éº: {}", e);
                }
            }

            // ÊÆã„Çä„ÅÆ„Çø„Çπ„ÇØ„ÇíÊõ¥Êñ∞
            active_tasks = remaining;
        }
    }

    // ÊÆã„Çä„ÅÆ„Çø„Çπ„ÇØ„ÇíÂÆå‰∫Ü„Åæ„ÅßÂæÖÊ©ü
    while !active_tasks.is_empty() {
        let (completed, _index, remaining) = futures::future::select_all(active_tasks).await;

        match completed {
            Ok(Ok(_)) => {
                info!("üéâ „Çø„Çπ„ÇØÂÆå‰∫Ü");
            }
            Ok(Err(e)) => {
                error!("‚ùå „Çø„Çπ„ÇØ„Ç®„É©„Éº: {}", e);
            }
            Err(e) => {
                error!("üí• „Çø„Çπ„ÇØÂÆüË°å„Ç®„É©„Éº: {}", e);
            }
        }

        active_tasks = remaining;
    }

    info!("‚úÖ „Åô„Åπ„Å¶„ÅÆ„Çø„Çπ„ÇØÂÆå‰∫ÜÔºÅ");

    Ok(())
}

// Ë®≠ÂÆö„Éï„Ç°„Ç§„É´Áî®ÊßãÈÄ†‰ΩìÔºàÂ∞ÜÊù•ÁöÑ„Å´Â§ñÈÉ®Âåñ„Åô„ÇãÂ†¥ÂêàÁî®Ôºâ
#[derive(Serialize, Deserialize)]
struct Config {
    github_token: String,
    output_dir: String,
    endpoints: Vec<Endpoint>,
    repos: Vec<RepoInfo>,
    concurrency: usize,
    max_files: usize,
    max_file_size: usize,
}
